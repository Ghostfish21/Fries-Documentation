<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-08-17T17:42:39.0568833"><title>Static Method Field | Fries</title><script type="application/json" id="virtual-toc-data">[{"id":"v7w6cm_6","level":0,"title":"快速开始","anchor":"#v7w6cm_6"},{"id":"v7w6cm_7","level":0,"title":"在构建中运行：缓存刷新步骤","anchor":"#v7w6cm_7"},{"id":"v7w6cm_8","level":0,"title":"参数匹配与限制","anchor":"#v7w6cm_8"},{"id":"v7w6cm_9","level":0,"title":"线程安全","anchor":"#v7w6cm_9"},{"id":"v7w6cm_10","level":0,"title":"故障排查","anchor":"#v7w6cm_10"},{"id":"v7w6cm_11","level":0,"title":"性能","anchor":"#v7w6cm_11"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Static Method Field | Fries"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Fries Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/static-method1.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Static Method Field | Fries"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/static-method1.html#webpage",
    "url": "writerside-documentation/static-method1.html",
    "name": "Static Method Field | Fries",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Fries Help"
}</script><!-- End Schema.org --></head><body data-id="Static_Method1" data-main-title="Static Method Field" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Overview.md|Fries Utils Pack 总览"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Fries  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Static_Method1" id="Static_Method1.md">Static Method Field</h1><p id="v7w6cm_3"><code class="code" id="v7w6cm_12">StaticMethod</code> 是一个可序列化类型 + 自定义 <code class="code" id="v7w6cm_13">PropertyDrawer</code> ，用于在 <span class="control" id="v7w6cm_14">Inspector</span> 中先选择一个 <code class="code" id="v7w6cm_15">MonoScript</code> ，再从其中挑选一个 <span class="control" id="v7w6cm_16">静态方法</span> （含私有/公有、支持重载）进行引用，并在代码中通过 <code class="code" id="v7w6cm_17">invoke(...)</code>/<code class="code" id="v7w6cm_18">invoke&lt;T&gt;(...)</code> 触发调用。 <br> 它在编辑器里缓存同名重载并构建&ldquo;参数类型签名 &rarr; 索引（及委托）&rdquo;的映射，以便在运行时以摊销 O(1) 的方式定位到对应重载并调用。</p><aside class="prompt" data-type="tip" data-title="" id="v7w6cm_4"><p id="v7w6cm_20"><span class="control" id="v7w6cm_21">构建支持（重要）</span> ：该模块<span class="control" id="v7w6cm_22">支持在 Player 构建中运行</span> ，但前提是你已在 <span class="control" id="v7w6cm_23">Editor</span> 中完成一次<span class="control" id="v7w6cm_24">缓存刷新</span> （见下文步骤）。构建后若更改了方法签名/重命名/移动命名空间，请回到 Editor 重新刷新缓存并重新构建。</p></aside><section class="chapter"><h2 id="v7w6cm_6" data-toc="v7w6cm_6">快速开始</h2><ol class="list _decimal" id="v7w6cm_25" type="1"><li class="list__item" id="v7w6cm_29"><p id="v7w6cm_32"><span class="control" id="v7w6cm_34">添加字段</span><br> 在你的组件/脚本里声明一个 <code class="code" id="v7w6cm_36">StaticMethod</code> 字段：</p><div class="code-block" data-lang="none">
using Fries.Inspector.MethodFields;
using UnityEngine;

public class MethodUser : MonoBehaviour
{
    [Header(&quot;在 Inspector 中选择脚本与静态方法&quot;)]
    public StaticMethod onStart;
    public StaticMethod calc;

    void Start()
    {
        // 无参静态方法
        onStart?.invoke();

        // 有返回值的静态方法
        int sum = calc.invoke&lt;int&gt;(2, 5);
        Debug.Log($&quot;Sum = {sum}&quot;);
    }
}
</div></li><li class="list__item" id="v7w6cm_30"><p id="v7w6cm_37"><span class="control" id="v7w6cm_39">在 Inspector 中选择方法</span></p><ul class="list _bullet" id="v7w6cm_38"><li class="list__item" id="v7w6cm_40"><p id="v7w6cm_43">将包含目标方法的 <code class="code" id="v7w6cm_44">MonoScript</code> 拖入字段；</p></li><li class="list__item" id="v7w6cm_41"><p id="v7w6cm_45">在右侧下拉列表中选择一个 <span class="control" id="v7w6cm_46">静态方法</span> 名称（支持私有/公有）；</p></li><li class="list__item" id="v7w6cm_42"><p id="v7w6cm_47">若该方法存在多个重载，运行时将按实参类型 <span class="control" id="v7w6cm_48">精确匹配</span> 对应的重载。</p></li></ul></li><li class="list__item" id="v7w6cm_31"><p id="v7w6cm_49"><span class="control" id="v7w6cm_51">提供要调用的静态方法</span></p><div class="code-block" data-lang="none">
public static class GameActions
{
    // 无参
    public static void Ping()
    {
        Debug.Log(&quot;Ping&quot;);
    }

    // 有参 + 返回值（支持重载）
    public static int Add(int a, int b) =&gt; a + b;
    public static float Add(float a, float b) =&gt; a + b;
}
</div></li></ol><aside class="prompt" data-type="tip" data-title="" id="v7w6cm_26"><p id="v7w6cm_52"><code class="code" id="v7w6cm_53">StaticMethodDrawer</code> 以<span class="control" id="v7w6cm_54">单行</span>绘制：左侧为字段名，中间为 <code class="code" id="v7w6cm_55">MonoScript</code> ，右侧为方法下拉。若更换 <code class="code" id="v7w6cm_56">MonoScript</code> ，已选方法名会被清空以避免指向失效。</p></aside><figure id="v7w6cm_27"><img alt="Static Method Field.jpg" src="Fries-Documentation/Static%20Method%20Field.jpg" title="Static Method Field.jpg" width="880" height="45"></figure></section><section class="chapter"><h2 id="v7w6cm_7" data-toc="v7w6cm_7">在构建中运行：缓存刷新步骤</h2><p id="v7w6cm_57">为确保 Player 构建能找到并调用你选择的静态方法，请在 <span class="control" id="v7w6cm_60">构建前</span>完成以下步骤：</p><ol class="list _decimal" id="v7w6cm_58" type="1"><li class="list__item" id="v7w6cm_61"><p id="v7w6cm_65"><span class="control" id="v7w6cm_66">在 Editor 的 Inspector 中完成一次选择</span><br> 选择 承载了 <code class="code" id="v7w6cm_68">Static Method</code> 的相应 <code class="code" id="v7w6cm_69">MonoBehaviour</code> 的相应 <code class="code" id="v7w6cm_70">GameObject</code> 。此操作会触发内部 <code class="code" id="v7w6cm_71">init()</code> ，将<span class="control" id="v7w6cm_72">参数签名 &rarr; 重载索引</span>写入可序列化缓存（<code class="code" id="v7w6cm_73">argTypesSave</code>）。</p></li><li class="list__item" id="v7w6cm_62"><p id="v7w6cm_74"><span class="control" id="v7w6cm_75">（可选但推荐）在 Editor 进入一次 Play 模式</span><br> 通过实际调用验证： <code class="code" id="v7w6cm_77">invoke(...)</code>/<code class="code" id="v7w6cm_78">invoke&lt;T&gt;(...)</code> 能命中预期重载且返回值正确。</p></li><li class="list__item" id="v7w6cm_63"><p id="v7w6cm_79"><span class="control" id="v7w6cm_80">保存场景 / 资源</span><br> 使用 <code class="code" id="v7w6cm_82">Ctrl/Cmd + S</code> 保存。这样缓存会写入到场景/资源中，随构建带入 Player。</p></li><li class="list__item" id="v7w6cm_64"><p id="v7w6cm_83"><span class="control" id="v7w6cm_84">构建 Player</span><br> 如之后修改了方法签名/重命名/移动命名空间，请回到 Editor 重新执行 1-3 步并重新构建。</p></li></ol></section><section class="chapter"><h2 id="v7w6cm_8" data-toc="v7w6cm_8">参数匹配与限制</h2><ul class="list _bullet" id="v7w6cm_86"><li class="list__item" id="v7w6cm_88"><p id="v7w6cm_91"><span class="control" id="v7w6cm_93">精确匹配</span> ：重载通过&ldquo;参数类型的 <code class="code" id="v7w6cm_94">FullName</code> 串联&rdquo;来定位（形如 <code class="code" id="v7w6cm_95">&quot;System.Int32 | System.String&quot;</code> ）。调用时需要让 <span class="control" id="v7w6cm_96">实参类型逐一与形参类型完全一致</span>：</p><ul class="list _bullet" id="v7w6cm_92"><li class="list__item" id="v7w6cm_97"><p id="v7w6cm_100">不进行隐式数值转换（<code class="code" id="v7w6cm_101">int</code> 与 <code class="code" id="v7w6cm_102">float</code> 不互通）；</p></li><li class="list__item" id="v7w6cm_98"><p id="v7w6cm_103">多态不参与匹配（传入子类对象不会匹配到 <code class="code" id="v7w6cm_104">Base</code> 形参）；</p></li><li class="list__item" id="v7w6cm_99"><p id="v7w6cm_105">字面量请使用正确类型（例如 <code class="code" id="v7w6cm_106">0</code> 是 <code class="code" id="v7w6cm_107">int</code>， <code class="code" id="v7w6cm_108">0f</code> 才是 <code class="code" id="v7w6cm_109">float</code>）。</p></li></ul></li><li class="list__item" id="v7w6cm_89"><p id="v7w6cm_110"><span class="control" id="v7w6cm_111">方法可见性</span> ：公有/私有静态方法均可被枚举到（<code class="code" id="v7w6cm_112">BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static</code>）。</p></li><li class="list__item" id="v7w6cm_90"><p id="v7w6cm_113"><span class="control" id="v7w6cm_115">不支持的形态</span>：</p><ul class="list _bullet" id="v7w6cm_114"><li class="list__item" id="v7w6cm_116"><p id="v7w6cm_118"><code class="code" id="v7w6cm_119">ref</code>/<code class="code" id="v7w6cm_120">out</code> 参数（委托创建与类型签名都不友好）。</p></li><li class="list__item" id="v7w6cm_117"><p id="v7w6cm_121"><span class="control" id="v7w6cm_122">未构造的泛型方法</span> （不会自动进行类型实参推断/构造）。</p></li></ul></li></ul></section><section class="chapter"><h2 id="v7w6cm_9" data-toc="v7w6cm_9">线程安全</h2><ul class="list _bullet" id="v7w6cm_123"><li class="list__item" id="v7w6cm_125"><p id="v7w6cm_127"><code class="code" id="v7w6cm_128">PropertyDrawer</code> 与 Unity 的序列化/绘制流程仅在 <span class="control" id="v7w6cm_129">主线程</span> 安全。</p></li><li class="list__item" id="v7w6cm_126"><p id="v7w6cm_130">运行时调用 <code class="code" id="v7w6cm_131">invoke(...)</code> 同样应在主线程触发（典型用法是 <code class="code" id="v7w6cm_132">MonoBehaviour</code> 生命周期或 Unity 事件回调）。</p></li></ul></section><section class="chapter"><h2 id="v7w6cm_10" data-toc="v7w6cm_10">故障排查</h2><ul class="list _bullet" id="v7w6cm_133"><li class="list__item" id="v7w6cm_135"><p id="v7w6cm_140"><span class="control" id="v7w6cm_141">症状</span> ：下拉显示 <span class="emphasis" id="v7w6cm_142">&ldquo;No script found&rdquo;</span><br><span class="control" id="v7w6cm_144">排查</span> ：尚未指定 <code class="code" id="v7w6cm_145">MonoScript</code> 。在字段中拖入包含目标方法的脚本。</p></li><li class="list__item" id="v7w6cm_136"><p id="v7w6cm_146"><span class="control" id="v7w6cm_147">症状</span> ：下拉显示 <span class="emphasis" id="v7w6cm_148">&ldquo;No class found in script&rdquo;</span><br><span class="control" id="v7w6cm_150">排查</span> ：该 <code class="code" id="v7w6cm_151">MonoScript</code> 未能解析出首个类（例如仅包含顶级函数/不规范声明）；请确认脚本内存在可解析的类型。</p></li><li class="list__item" id="v7w6cm_137"><p id="v7w6cm_152"><span class="control" id="v7w6cm_153">症状</span> ：下拉显示 <span class="emphasis" id="v7w6cm_154">&ldquo;No static method found&rdquo;</span><br><span class="control" id="v7w6cm_156">排查</span> ：脚本中无任何静态方法；或方法为实例方法。将目标方法改为 <code class="code" id="v7w6cm_157">static</code>。</p></li><li class="list__item" id="v7w6cm_138"><p id="v7w6cm_158"><span class="control" id="v7w6cm_159">症状</span> ：构建后 <code class="code" id="v7w6cm_160">invoke(...)</code> 未生效或报错（找不到重载 / <code class="code" id="v7w6cm_161">KeyNotFoundException</code>） <br><span class="control" id="v7w6cm_163">排查</span> ：大多是<span class="control" id="v7w6cm_164">未在 Editor 刷新缓存</span>或构建前未保存场景；或目标方法在构建时被裁剪。重新执行&ldquo;缓存刷新步骤&rdquo;，并检查裁剪设置。</p></li><li class="list__item" id="v7w6cm_139"><p id="v7w6cm_165"><span class="control" id="v7w6cm_166">症状</span> ：参数类型看似一致但仍未命中重载<br><span class="control" id="v7w6cm_168">排查</span> ：确认传入的运行时类型（<code class="code" id="v7w6cm_169">GetType().FullName</code> ）与形参完全一致； <code class="code" id="v7w6cm_170">int</code>/<code class="code" id="v7w6cm_171">float</code> 、派生/基类都会导致不匹配。</p></li></ul></section><section class="chapter"><h2 id="v7w6cm_11" data-toc="v7w6cm_11">性能</h2><aside class="prompt" data-type="tip" data-title="" id="v7w6cm_172"><p id="v7w6cm_173"><code class="code" id="v7w6cm_174">StaticMethod.invoke</code> 实际上调用的是 <code class="code" id="v7w6cm_175">DynamicInvoke</code> ，可能产生 4000-20000 倍 于 <code class="code" id="v7w6cm_176">var value = 1f</code> 的消耗<br> 未来也许会更改为更节省性能的方法</p></aside></section><div class="last-modified">17 八月 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="insertion-event-system.html" class="navigation-links__prev">Insertion Event System</a><a href="hierarchy-button.html" class="navigation-links__next">Hierarchy Button</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>