<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-08-17T17:42:39.0708858"><title>Event Functions | Fries</title><script type="application/json" id="virtual-toc-data">[{"id":"-8xltg1_5","level":0,"title":"主要特性","anchor":"#-8xltg1_5"},{"id":"-8xltg1_6","level":0,"title":"快速开始","anchor":"#-8xltg1_6"},{"id":"api","level":0,"title":"API 参考","anchor":"#api"},{"id":"-8xltg1_8","level":0,"title":"常见问题","anchor":"#-8xltg1_8"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Event Functions | Fries"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Fries Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/event-functions.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Event Functions | Fries"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/event-functions.html#webpage",
    "url": "writerside-documentation/event-functions.html",
    "name": "Event Functions | Fries",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Fries Help"
}</script><!-- End Schema.org --></head><body data-id="Event_Functions" data-main-title="Event Functions" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Overview.md|Fries Utils Pack 总览"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Fries  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Event_Functions" id="Event_Functions.md">Event Functions</h1><p id="-8xltg1_3"><code class="code" id="-8xltg1_9">EventFunctions</code> 支持任意 对象 拥有类似 MonoBehaviour 的 FixedUpdate，Update，LateUpdate 方法</p><aside class="prompt" data-type="warning" data-title="" id="-8xltg1_4"><p id="-8xltg1_10">警告：功能尚未完善，EventFunction 的调用存在于 Update / FixedUpdate / LateUpdate 中，单次调用通过反射路径实时分析类型相对昂贵</p></aside><section class="chapter"><h2 id="-8xltg1_5" data-toc="-8xltg1_5">主要特性</h2><ul class="list _bullet" id="-8xltg1_11"><li class="list__item" id="-8xltg1_12"><p id="-8xltg1_19"><span class="control" id="-8xltg1_20">方法即事件</span>： <code class="code" id="-8xltg1_21">[EventFunctionDeclarer]</code> 标注的静态 <code class="code" id="-8xltg1_22">void</code> 方法即视为事件声明；方法名就是事件名， <span class="control" id="-8xltg1_23">形参列表即事件参数签名</span>。</p></li><li class="list__item" id="-8xltg1_13"><p id="-8xltg1_24"><span class="control" id="-8xltg1_25">零样板订阅</span> ：实例所属类实现 <code class="code" id="-8xltg1_26">EventFunctionSubscriber</code> ，并在构造器中调用 <code class="code" id="-8xltg1_27">this.subscribe()</code> 即可完成注册； <code class="code" id="-8xltg1_28">this.unsubscribe()</code> 解除。方法上加 <code class="code" id="-8xltg1_29">[EventFunction]</code> 即可创建相应方法名的事件</p></li><li class="list__item" id="-8xltg1_14"><p id="-8xltg1_30"><span class="control" id="-8xltg1_31">强签名校验</span> ：订阅方法的<span class="control" id="-8xltg1_32">名称与参数类型</span>须与声明完全一致（含顺序与类型），否则在注册时日志报错。</p></li><li class="list__item" id="-8xltg1_15"><p id="-8xltg1_33"><span class="control" id="-8xltg1_34">内置生命周期事件</span> ：无需自写 <code class="code" id="-8xltg1_35">Update</code>/<code class="code" id="-8xltg1_36">FixedUpdate</code>/<code class="code" id="-8xltg1_37">LateUpdate</code> ，可直接订阅 <code class="code" id="-8xltg1_38">update/fixedUpdate/lateUpdate</code> 。可以用于 ScriptableObject / StateMachineBehaviour 或其他场景中</p></li><li class="list__item" id="-8xltg1_16"><p id="-8xltg1_39"><span class="control" id="-8xltg1_40">自动清理</span> ：当订阅者是 <code class="code" id="-8xltg1_41">UnityEngine.Object</code> 且已被销毁时，系统会在触发过程中检测并移除其注册。</p></li><li class="list__item" id="-8xltg1_17"><p id="-8xltg1_42"><span class="control" id="-8xltg1_43">跨程序集扫描</span> ：可通过 <code class="code" id="-8xltg1_44">loadAssemblies</code> 指定要扫描事件声明的程序集列表</p></li><li class="list__item" id="-8xltg1_18"><p id="-8xltg1_45"><span class="control" id="-8xltg1_46">非侵入设计</span> ：订阅者无需继承特定基类，仅需实现接口 <code class="code" id="-8xltg1_47">EventFunctionSubscriber</code> ；事件函数使用属性标注。</p></li></ul></section><section class="chapter"><h2 id="-8xltg1_6" data-toc="-8xltg1_6">快速开始</h2><section class="chapter"><h3 id="1" data-toc="1">1）场景中放置系统</h3><p id="-8xltg1_52">将 <code class="code" id="-8xltg1_54">EventFunctionSystem</code> 挂到任意场景物体（建议打上 <code class="code" id="-8xltg1_55">DontDestroyOnLoad</code> 的全局对象）。如希望限制事件声明的扫描范围，可在 <code class="code" id="-8xltg1_56">loadAssemblies</code> 中填入<span class="control" id="-8xltg1_57">要扫描的程序集名称</span> （不需填入 <code class="code" id="-8xltg1_58">Assembly-CSharp</code> 因为已经自动填入）。</p><div class="code-block" data-lang="none">
// 典型做法：在引导场景中放置一个带 EventFunctionSystem 的 GameObject
// 并仅保留一个实例（系统内部已做单例保护）。
</div></section><section class="chapter"><h3 id="2" data-toc="2">2）编写订阅者并注册自身进入系统中</h3><div class="code-block" data-lang="none">
using Fries.EventFunctions;
using UnityEngine;

public class EnemySpawnLogger : MonoBehaviour, EventFunctionSubscriber
{
    // 建议在 OnEnable/OnDisable 中完成注册/反注册
    private void OnEnable()  =&gt; this.subscribe();
    private void OnDisable() =&gt; this.unsubscribe();

    // 接口回调，这些方法会在 注册/反注册后立刻被调用
    public void onSubscribe()   { /* optional init */ }
    public void onUnsubscribe() { /* optional dispose */ }
}
</div></section><section class="chapter"><h3 id="3" data-toc="3">3）订阅事件</h3><div class="code-block" data-lang="none">
    // 订阅内置的无参 update 事件（等同于传统 Update 但可集中分发）
    [EventFunction]
    private void update() {
        // per-frame logic
    }
</div><aside class="prompt" data-type="tip" data-title="" id="-8xltg1_61"><p id="-8xltg1_62"><code class="code" id="-8xltg1_63">EventFunctionSystem</code> 会在自身的 <code class="code" id="-8xltg1_64">Update/FixedUpdate/LateUpdate</code> 中分别触发 <code class="code" id="-8xltg1_65">update/fixedUpdate/lateUpdate</code>。</p></aside></section><section class="chapter"><h3 id="4" data-toc="4">4）运行</h3><ul class="list _bullet" id="-8xltg1_66"><li class="list__item" id="-8xltg1_67"><p id="-8xltg1_69">确保场景中<span class="control" id="-8xltg1_70">仅有一个</span> <code class="code" id="-8xltg1_71">EventFunctionSystem</code> 实例（系统会在 <code class="code" id="-8xltg1_72">Awake</code> 中自我保护，多余实例会销毁）。</p></li><li class="list__item" id="-8xltg1_68"><p id="-8xltg1_73">进入 Awake 后，系统会反射扫描 <code class="code" id="-8xltg1_74">[EventFunctionDeclarer]</code> ，建立事件名 &rarr; 参数类型签名映射，然后才能正确登记订阅者。请确保你不在 Awake 阶段进行注册/反注册操作</p></li></ul></section></section><section class="chapter"><h2 id="api" data-toc="api">API 参考</h2><section class="chapter"><h3 id="eventfunctiondeclarer" data-toc="eventfunctiondeclarer"><code class="code" id="-8xltg1_84">[EventFunctionDeclarer]</code></h3><p id="-8xltg1_81"><span class="control" id="-8xltg1_85">用途</span> ：标注<span class="control" id="-8xltg1_86">静态 <code class="code" id="-8xltg1_94">void</code> 方法</span>为&ldquo;事件声明&rdquo;。方法名即事件名； <span class="control" id="-8xltg1_87">形参类型</span>即该事件的<span class="control" id="-8xltg1_88">签名</span>。 <br><span class="control" id="-8xltg1_90">扫描位置</span> ：由 <code class="code" id="-8xltg1_91">EventFunctionSystem.loadAssemblies</code> 指定的程序集范围。 <br><span class="control" id="-8xltg1_93">内置声明</span>：</p><div class="code-block" data-lang="none">
[EventFunctionDeclarer] public static void update() {}
[EventFunctionDeclarer] public static void fixedUpdate() {}
[EventFunctionDeclarer] public static void lateUpdate() {}
</div></section><section class="chapter"><h3 id="eventfunction" data-toc="eventfunction"><code class="code" id="-8xltg1_98">[EventFunction]</code></h3><p id="-8xltg1_96"><span class="control" id="-8xltg1_99">用途</span> ：标注<span class="control" id="-8xltg1_100">实例方法</span>为事件订阅入口。方法名与参数类型必须与某个已声明事件<span class="control" id="-8xltg1_101">完全一致</span> （含顺序与具体类型）。</p></section><section class="chapter"><h3 id="interface-eventfunctionsubscriber" data-toc="interface-eventfunctionsubscriber"><code class="code" id="-8xltg1_107">interface EventFunctionSubscriber</code></h3><p id="-8xltg1_103"><span class="control" id="-8xltg1_108">接口方法列表</span></p><div class="code-block" data-lang="none">
public interface EventFunctionSubscriber {
    void onSubscribe();
    void onUnsubscribe();
}
</div><p id="-8xltg1_105"><span class="control" id="-8xltg1_109">说明</span> ：用于与扩展方法配合。 <code class="code" id="-8xltg1_110">subscribe()</code> 成功登记后会回调 <code class="code" id="-8xltg1_111">onSubscribe()</code>； <code class="code" id="-8xltg1_112">unsubscribe()</code> 移除后回调 <code class="code" id="-8xltg1_113">onUnsubscribe()</code>。</p></section><section class="chapter"><h3 id="eventfunctionsubscriberextensions-subscribe-unsubscribe" data-toc="eventfunctionsubscriberextensions-subscribe-unsubscribe"><code class="code" id="-8xltg1_119">EventFunctionSubscriberExtensions.subscribe()</code>/<code class="code" id="-8xltg1_120">unsubscribe()</code></h3><p id="-8xltg1_115"><span class="control" id="-8xltg1_121">签名</span></p><div class="code-block" data-lang="none">
public static void subscribe(this EventFunctionSubscriber subscriber)
public static void unsubscribe(this EventFunctionSubscriber subscriber)
</div><p id="-8xltg1_117"><span class="control" id="-8xltg1_122">作用</span> ：对实现了 <code class="code" id="-8xltg1_123">EventFunctionSubscriber</code> 的对象进行<span class="control" id="-8xltg1_124">注册/反注册</span> 。只有注册了的对象才会被 EventFunction 系统管理<br><span class="control" id="-8xltg1_126">调用时机建议</span>： <code class="code" id="-8xltg1_127">OnEnable()/Start()</code> 调 <code class="code" id="-8xltg1_128">subscribe()</code>， <code class="code" id="-8xltg1_129">OnDisable()/OnDestroy()</code> 调 <code class="code" id="-8xltg1_130">unsubscribe()</code>。</p></section><section class="chapter"><h3 id="class-eventfunctionsystem-monobehaviour" data-toc="class-eventfunctionsystem-monobehaviour"><code class="code" id="-8xltg1_141">class EventFunctionSystem : MonoBehaviour</code></h3><p id="-8xltg1_132"><span class="control" id="-8xltg1_142">单例访问</span></p><div class="code-block" data-lang="none">
public static EventFunctionSystem inst { get; }
</div><p id="-8xltg1_134"><span class="control" id="-8xltg1_143">配置项</span></p><div class="code-block" data-lang="none">
public string[] loadAssemblies; // 要扫描事件声明的程序集名称数组
</div><p id="-8xltg1_136"><span class="control" id="-8xltg1_144">核心方法</span></p><div class="code-block" data-lang="none">
public void record(object obj);                           // 将对象加入待登记队列
public void remove(object obj);                           // 将对象加入待移除队列
public void trigger(string eventName, params object[] args); // 触发事件
</div><p id="-8xltg1_138"><span class="control" id="-8xltg1_145">行为细节</span></p><ul class="list _bullet" id="-8xltg1_139"><li class="list__item" id="-8xltg1_146"><p id="-8xltg1_149"><span class="control" id="-8xltg1_150">重复订阅</span> ：同一 <code class="code" id="-8xltg1_151">obj</code> 对同一事件的登记会被覆盖为最后一次生成的委托。</p></li><li class="list__item" id="-8xltg1_147"><p id="-8xltg1_152"><span class="control" id="-8xltg1_153">销毁清理</span> ：分发时若检测到 <code class="code" id="-8xltg1_154">UnityEngine.Object</code> 已失效，会自动移除其订阅。</p></li><li class="list__item" id="-8xltg1_148"><p id="-8xltg1_155"><span class="control" id="-8xltg1_157">错误提示</span>：</p><ul class="list _bullet" id="-8xltg1_156"><li class="list__item" id="-8xltg1_158"><p id="-8xltg1_161">未找到事件声明 &rarr; <code class="code" id="-8xltg1_162">Couldn't find Event Function named &lt;name&gt;!</code></p></li><li class="list__item" id="-8xltg1_159"><p id="-8xltg1_163">名称匹配但签名不一致 &rarr; <code class="code" id="-8xltg1_164">Couldn't find Event Function named &lt;name&gt; with argument types ...</code></p></li><li class="list__item" id="-8xltg1_160"><p id="-8xltg1_165">预注册委托为空（理论上不应发生）&rarr; 明确错误日志提示。</p></li></ul></li></ul><aside class="prompt" data-type="tip" data-title="" id="-8xltg1_140"><p id="-8xltg1_166"><span class="control" id="-8xltg1_167">实现提示</span>： <code class="code" id="-8xltg1_168">record()</code> 与 <code class="code" id="-8xltg1_169">remove()</code> 为<span class="control" id="-8xltg1_170">异步到下一次触发</span>执行的&ldquo;排队操作&rdquo;；若你在同一帧需要立即生效，可主动调用一次 <code class="code" id="-8xltg1_171">trigger(...)</code> （如触发一个无订阅者影响的哑事件）来刷新缓冲。</p></aside></section></section><section class="chapter"><h2 id="-8xltg1_8" data-toc="-8xltg1_8">常见问题</h2><p id="-8xltg1_172"><span class="control" id="-8xltg1_176">Q：我标注了 <code class="code" id="-8xltg1_180">[EventFunction]</code> ，但运行时报 &ldquo;Couldn't find Event Function named &hellip;&rdquo;</span><br> A：检查是否<span class="control" id="-8xltg1_178">存在同名的 <code class="code" id="-8xltg1_181">[EventFunctionDeclarer]</code> 静态 <code class="code" id="-8xltg1_182">void</code> 方法</span> ；以及 <code class="code" id="-8xltg1_179">EventFunctionSystem</code> 是否在本场景中激活。</p><p id="-8xltg1_173"><span class="control" id="-8xltg1_183">Q：签名不匹配怎么办？</span><br> A：订阅方法的形参类型与顺序必须与声明<span class="control" id="-8xltg1_185">一字不差</span> 。例如 <code class="code" id="-8xltg1_186">int, Vector3</code> 与 <code class="code" id="-8xltg1_187">Vector3, int</code> 视为不同签名。</p><p id="-8xltg1_174"><span class="control" id="-8xltg1_188">Q：订阅对象销毁后要不要手动 <code class="code" id="-8xltg1_195">unsubscribe()</code>？</span><br> A：不必须。系统在触发过程中会检测到失效的 <code class="code" id="-8xltg1_190">UnityEngine.Object</code> 并自动清理；但<span class="control" id="-8xltg1_191">推荐</span>在 <code class="code" id="-8xltg1_192">OnDisable</code> 主动 <code class="code" id="-8xltg1_193">unsubscribe()</code> 明确语义。而且需要注意的是，如果你的对象不是 UnityEngine.Object，那么手动 <code class="code" id="-8xltg1_194">unsubscribe()</code> 是必须的</p><p id="-8xltg1_175"><span class="control" id="-8xltg1_196">Q：能否不实现 <code class="code" id="-8xltg1_201">EventFunctionSubscriber</code> 也订阅？</span><br> A：可以手动调用 <code class="code" id="-8xltg1_198">EventFunctionSystem.inst.record(obj)</code> ，但失去 <code class="code" id="-8xltg1_199">onSubscribe/onUnsubscribe</code> 回调与统一入口的便利； <span class="control" id="-8xltg1_200">推荐</span>实现接口并使用扩展方法。</p></section><div class="last-modified">17 八月 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="multi-tag.html" class="navigation-links__prev">Multi Tag</a><a href="insertion-event-system.html" class="navigation-links__next">Insertion Event System</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>