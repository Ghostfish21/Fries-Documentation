<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-08-17T17:42:39.0758874"><title>Task Performer | Fries</title><script type="application/json" id="virtual-toc-data">[{"id":"-6uyfan_6","level":0,"title":"快速开始","anchor":"#-6uyfan_6"},{"id":"api","level":0,"title":"API 参考","anchor":"#api"},{"id":"-6uyfan_8","level":0,"title":"线程安全","anchor":"#-6uyfan_8"},{"id":"-6uyfan_9","level":0,"title":"故障排查","anchor":"#-6uyfan_9"},{"id":"taskperformer","level":0,"title":"性能说明（仅 TaskPerformer 方法）","anchor":"#taskperformer"},{"id":"-6uyfan_11","level":0,"title":"使用建议","anchor":"#-6uyfan_11"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Task Performer | Fries"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Fries Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/task-performer.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Task Performer | Fries"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/task-performer.html#webpage",
    "url": "writerside-documentation/task-performer.html",
    "name": "Task Performer | Fries",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Fries Help"
}</script><!-- End Schema.org --></head><body data-id="Task_Performer" data-main-title="Task Performer" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Overview.md|Fries Utils Pack 总览"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Fries  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Task_Performer" id="Task_Performer.md">Task Performer</h1><p id="-6uyfan_3"><code class="code" id="-6uyfan_12">TaskPerformer</code> 模块是一组用于 <span class="control" id="-6uyfan_13">把任意线程的任务调度到 Unity 主线程执行</span> 的实用工具，并配套&ldquo; <span class="control" id="-6uyfan_14">标记动作（Labeled Action）</span> &rdquo;机制以通过字符串标签间接调用方法。 <br> 它适用于：从后端线程/异步任务向主线程提交工作、基于条件/时间的延迟与重复执行、以字符串查找与执行方法等场景。</p><aside class="prompt" data-type="tip" data-title="" id="-6uyfan_4"><p id="-6uyfan_16">设计要点：</p><ul class="list _bullet" id="-6uyfan_17"><li class="list__item" id="-6uyfan_18"><p id="-6uyfan_21">主体执行器 <code class="code" id="-6uyfan_22">TaskPerformer</code> 采用 <span class="control" id="-6uyfan_23">单例组件</span> （<code class="code" id="-6uyfan_24">DontDestroyOnLoad</code> ），在 <code class="code" id="-6uyfan_25">Update()</code> 中逐帧取出并执行任务。</p></li><li class="list__item" id="-6uyfan_19"><p id="-6uyfan_26">入队结构使用 <code class="code" id="-6uyfan_27">ConcurrentQueue</code>/<code class="code" id="-6uyfan_28">ConcurrentDictionary</code>， <span class="control" id="-6uyfan_29">可在任意线程安全入队</span> ；真正执行始终在主线程。</p></li><li class="list__item" id="-6uyfan_20"><p id="-6uyfan_30">标记动作由 <code class="code" id="-6uyfan_31">LabeledActionAttribute</code> 扫描并注册（支持 Editor 自动注册）。方法以 <span class="control" id="-6uyfan_32">标签字符串</span> 进行索引、查找与调用。</p></li></ul></aside><section class="chapter"><h2 id="-6uyfan_6" data-toc="-6uyfan_6">快速开始</h2><ol class="list _decimal" id="-6uyfan_33" type="1"><li class="list__item" id="-6uyfan_36"><p id="-6uyfan_39">在启动场景中新建一个空物体并 <span class="control" id="-6uyfan_40">添加组件</span>： <code class="code" id="-6uyfan_41">TaskPerformer</code> （建议命名为 <code class="code" id="-6uyfan_42">_TaskPerformer</code> 并常驻场景）。</p></li><li class="list__item" id="-6uyfan_37"><p id="-6uyfan_43">（可选）给需要通过字符串调用的方法添加 <code class="code" id="-6uyfan_46">LabeledAction</code>：</p><div class="code-block" data-lang="none">
using Fries.TaskPerformer;
public class MyOps {
    [LabeledAction(&quot;Tools/Hello&quot;)]
    public static object Say(object[] args) {
        Debug.Log($&quot;Hello {args?[0] ?? &quot;World&quot;}&quot;);
        return null; // 返回类型必须是 object
    }
}
</div><ul class="list _bullet" id="-6uyfan_45"><li class="list__item" id="-6uyfan_47"><p id="-6uyfan_48">在 <span class="control" id="-6uyfan_49">Editor</span> 中会自动调用 <code class="code" id="-6uyfan_50">LabeledActionAttribute.load()</code> 进行注册；在 <span class="control" id="-6uyfan_51">Player</span> 中请手动调用一次 <code class="code" id="-6uyfan_52">LabeledActionAttribute.load()</code> （例如游戏启动时）。</p></li></ul></li><li class="list__item" id="-6uyfan_38"><p id="-6uyfan_53">在任意线程 <span class="control" id="-6uyfan_55">调度任务到主线程执行</span>：</p><div class="code-block" data-lang="none">
using System.Threading.Tasks;
using Fries.TaskPerformer;
using UnityEngine;

public class Demo : MonoBehaviour {
    void Start() {
        // 立即在主线程执行（下一帧取出执行）
        TaskPerformer.inst().scheduleTask(() =&gt; Debug.Log(&quot;tick&quot;));

        // 携带参数的任务（使用 ParamedAction.pa 构造）
        TaskPerformer.inst().scheduleTask(ParamedAction.pa(objs =&gt; {
            Debug.Log($&quot;param[0]={objs[0]}&quot;);
        }, 42));

        // 延时 0.5s 执行一次
        TaskPerformer.inst().scheduleTask(() =&gt; Debug.Log(&quot;delayed&quot;), 0.5f);

        // 条件满足时执行一次
        bool ready = false;
        Invoke(nameof(MakeReady), 1f);
        TaskPerformer.inst().scheduleTaskWhen(() =&gt; Debug.Log(&quot;ready!&quot;), () =&gt; ready);

        // 条件循环执行，最多 3 次
        TaskPerformer.inst().scheduleRepeatingTaskWhen(() =&gt; Debug.Log(&quot;repeat-when&quot;), () =&gt; Time.frameCount % 30 == 0, executeTime: 3);

        // 固定间隔循环执行（-1 表示无限）
        var h = TaskPerformer.inst().scheduleRepeatingTask(() =&gt; Debug.Log(&quot;repeat&quot;), 1f, executeTime: -1);
        // 随后可随时取消：h.cancel();

        // 通过标签执行（返回值示例）
        TaskPerformer.executeLabeledAction(&quot;Tools/Hello&quot;, new object[] { &quot;Alice&quot; });
    }

    void MakeReady() =&gt; Debug.Log(&quot;set ready&quot;);
}
</div></li></ol><aside class="prompt" data-type="tip" data-title="" id="-6uyfan_34"><p id="-6uyfan_56">生命周期： <code class="code" id="-6uyfan_57">TaskPerformer</code> 在 <code class="code" id="-6uyfan_58">construct()</code> （初始化阶段）建立单例并 <code class="code" id="-6uyfan_59">DontDestroyOnLoad</code>； <code class="code" id="-6uyfan_60">Update()</code> 每帧拉取并执行队列中的 <span class="control" id="-6uyfan_61">至多一个</span> 任务，同时评估条件/重复任务。</p></aside></section><section class="chapter"><h2 id="api" data-toc="api">API 参考</h2><section class="chapter"><h3 id="fries-taskperformer-labeledactionattribute" data-toc="fries-taskperformer-labeledactionattribute">标记动作： <code class="code" id="-6uyfan_71">Fries.TaskPerformer.LabeledActionAttribute</code></h3><div class="table-wrapper"><table class="wide" id="-6uyfan_67"><thead><tr class="ijRowHead" id="-6uyfan_72"><th id="-6uyfan_78"><p>成员</p></th><th id="-6uyfan_79"><p>签名</p></th><th id="-6uyfan_80"><p>行为</p></th></tr></thead><tbody><tr id="-6uyfan_73"><td id="-6uyfan_81"><p><span class="control" id="-6uyfan_84">构造</span></p></td><td id="-6uyfan_82"><p><code class="code" id="-6uyfan_85">LabeledActionAttribute(string label)</code></p></td><td id="-6uyfan_83"><p>为方法声明标签（如 <code class="code" id="-6uyfan_86">&quot;Tools/Hello&quot;</code>）。</p></td></tr><tr id="-6uyfan_74"><td id="-6uyfan_87"><p><span class="control" id="-6uyfan_90">注册（Editor）</span></p></td><td id="-6uyfan_88"><p><code class="code" id="-6uyfan_91">[InitializeOnLoadMethod] static void loadDefault()</code></p></td><td id="-6uyfan_89"><p>在编辑器载入时自动调用 <code class="code" id="-6uyfan_92">load()</code>。</p></td></tr><tr id="-6uyfan_75"><td id="-6uyfan_93"><p><span class="control" id="-6uyfan_96">注册</span></p></td><td id="-6uyfan_94"><p><code class="code" id="-6uyfan_97">static void load(string[] loadAssembly = null)</code></p></td><td id="-6uyfan_95"><p>扫描并注册含有 <code class="code" id="-6uyfan_98">LabeledActionAttribute</code> 的方法。默认尝试 <code class="code" id="-6uyfan_99">Assembly-CSharp</code> 与当前程序集；也可指定额外程序集名。</p></td></tr><tr id="-6uyfan_76"><td id="-6uyfan_100"><p><span class="control" id="-6uyfan_103">执行（泛型）</span></p></td><td id="-6uyfan_101"><p><code class="code" id="-6uyfan_104">static T TaskPerformer.executeLabeledAction&lt;T&gt;(string label, object[] param, object target = null)</code></p></td><td id="-6uyfan_102"><p>按标签查找并执行，返回 <code class="code" id="-6uyfan_105">T</code> 。对于 <span class="control" id="-6uyfan_106">实例方法</span> ，需提供 <code class="code" id="-6uyfan_107">target</code>。</p></td></tr><tr id="-6uyfan_77"><td id="-6uyfan_108"><p><span class="control" id="-6uyfan_111">执行（无返回）</span></p></td><td id="-6uyfan_109"><p><code class="code" id="-6uyfan_112">static void TaskPerformer.executeLabeledAction(string label, object[] param, object target = null)</code></p></td><td id="-6uyfan_110"><p>忽略返回值。</p></td></tr></tbody></table></div><p id="-6uyfan_68"><span class="control" id="-6uyfan_113">方法签名约束</span> （被标注的方法）：</p><ul class="list _bullet" id="-6uyfan_69"><li class="list__item" id="-6uyfan_114"><p id="-6uyfan_117"><span class="control" id="-6uyfan_118">参数</span>： <span class="control" id="-6uyfan_119">仅允许</span>一个参数，类型为 <code class="code" id="-6uyfan_120">object[]</code>。</p></li><li class="list__item" id="-6uyfan_115"><p id="-6uyfan_121"><span class="control" id="-6uyfan_122">返回</span> ：必须为 <code class="code" id="-6uyfan_123">object</code> （如无返回可 <code class="code" id="-6uyfan_124">return null</code>）。</p></li><li class="list__item" id="-6uyfan_116"><p id="-6uyfan_125"><span class="control" id="-6uyfan_126">静/实例</span> ：均可。若为实例方法，调用时 <code class="code" id="-6uyfan_127">target</code> 不可为 <code class="code" id="-6uyfan_128">null</code>。</p></li></ul></section><section class="chapter"><h3 id="fries-taskperformer-paramedaction" data-toc="fries-taskperformer-paramedaction">任务载体： <code class="code" id="-6uyfan_133">Fries.TaskPerformer.ParamedAction</code></h3><div class="table-wrapper"><table class="wide" id="-6uyfan_130"><thead><tr class="ijRowHead" id="-6uyfan_134"><th id="-6uyfan_139"><p>成员</p></th><th id="-6uyfan_140"><p>签名</p></th><th id="-6uyfan_141"><p>行为</p></th></tr></thead><tbody><tr id="-6uyfan_135"><td id="-6uyfan_142"><p><span class="control" id="-6uyfan_145">工厂</span></p></td><td id="-6uyfan_143"><p><code class="code" id="-6uyfan_146">static ParamedAction pa(Action&lt;object[]&gt; action, params object[] param)</code></p></td><td id="-6uyfan_144"><p>构造带参任务，参数将作为 <code class="code" id="-6uyfan_147">object[]</code> 传入。</p></td></tr><tr id="-6uyfan_136"><td id="-6uyfan_148"><p><span class="control" id="-6uyfan_151">工厂（无参）</span></p></td><td id="-6uyfan_149"><p><code class="code" id="-6uyfan_152">static ParamedAction pa(Action action)</code></p></td><td id="-6uyfan_150"><p>构造<span class="control" id="-6uyfan_153">无参</span>任务，内部包装为 <code class="code" id="-6uyfan_154">Action&lt;object[]&gt;</code>。</p></td></tr><tr id="-6uyfan_137"><td id="-6uyfan_155"><p><span class="control" id="-6uyfan_158">隐式</span></p></td><td id="-6uyfan_156"><p><code class="code" id="-6uyfan_159">implicit operator ParamedAction(Action action)</code></p></td><td id="-6uyfan_157"><p>允许将 <code class="code" id="-6uyfan_160">Action</code> 直接传入调度器。</p></td></tr><tr id="-6uyfan_138"><td id="-6uyfan_161"><p><span class="control" id="-6uyfan_164">字段</span></p></td><td id="-6uyfan_162"><p><code class="code" id="-6uyfan_165">Action&lt;object[]&gt; action; object[] param; TaskHandle taskHandle;</code></p></td><td id="-6uyfan_163"><p>任务逻辑、参数与句柄。</p></td></tr></tbody></table></div><aside class="prompt" data-type="tip" data-title="" id="-6uyfan_131"><p id="-6uyfan_166"><code class="code" id="-6uyfan_167">TaskPerformer</code> 在入队时会生成 <span class="control" id="-6uyfan_168">包装器</span> ：执行前检查取消标记，捕获异常、递增执行计数 <code class="code" id="-6uyfan_169">executedTime</code> ，触发回调 <code class="code" id="-6uyfan_170">onComplete</code> ，并标记 <code class="code" id="-6uyfan_171">isExecuted</code>。</p></aside></section><section class="chapter"><h3 id="fries-taskperformer-taskhandle" data-toc="fries-taskperformer-taskhandle">任务句柄： <code class="code" id="-6uyfan_175">Fries.TaskPerformer.TaskHandle</code></h3><div class="table-wrapper"><table class="wide" id="-6uyfan_173"><thead><tr class="ijRowHead" id="-6uyfan_176"><th id="-6uyfan_181"><p>成员</p></th><th id="-6uyfan_182"><p>签名 / 字段</p></th><th id="-6uyfan_183"><p>行为</p></th></tr></thead><tbody><tr id="-6uyfan_177"><td id="-6uyfan_184"><p><span class="control" id="-6uyfan_187">状态</span></p></td><td id="-6uyfan_185"><p><code class="code" id="-6uyfan_188">bool isCancelled</code>/<code class="code" id="-6uyfan_189">bool isExecuted</code>/<code class="code" id="-6uyfan_190">int executedTime</code></p></td><td id="-6uyfan_186"><p>取消标记、是否至少执行过一次、已执行次数。</p></td></tr><tr id="-6uyfan_178"><td id="-6uyfan_191"><p><span class="control" id="-6uyfan_194">回调</span></p></td><td id="-6uyfan_192"><p><code class="code" id="-6uyfan_195">Action onComplete</code></p></td><td id="-6uyfan_193"><p>每次执行后的回调。</p></td></tr><tr id="-6uyfan_179"><td id="-6uyfan_196"><p><span class="control" id="-6uyfan_199">数据</span></p></td><td id="-6uyfan_197"><p><code class="code" id="-6uyfan_200">Dictionary&lt;string, object&gt; data</code></p></td><td id="-6uyfan_198"><p>内置用于携带元数据（如 <code class="code" id="-6uyfan_201">&quot;MaxExecuteTime&quot;</code>）。</p></td></tr><tr id="-6uyfan_180"><td id="-6uyfan_202"><p><span class="control" id="-6uyfan_205">取消</span></p></td><td id="-6uyfan_203"><p><code class="code" id="-6uyfan_206">void cancel()</code></p></td><td id="-6uyfan_204"><p>标记取消：对 <span class="control" id="-6uyfan_207">尚未执行</span> 或 <span class="control" id="-6uyfan_208">重复任务的后续执行</span> 生效。</p></td></tr></tbody></table></div></section><section class="chapter"><h3 id="fries-taskperformer-taskperformer" data-toc="fries-taskperformer-taskperformer">执行器： <code class="code" id="-6uyfan_213">Fries.TaskPerformer.TaskPerformer</code></h3><div class="table-wrapper"><table class="wide" id="-6uyfan_210"><thead><tr class="ijRowHead" id="-6uyfan_214"><th id="-6uyfan_223"><p>方法</p></th><th id="-6uyfan_224"><p>签名</p></th><th id="-6uyfan_225"><p>行为</p></th></tr></thead><tbody><tr id="-6uyfan_215"><td id="-6uyfan_226"><p><span class="control" id="-6uyfan_229">获取实例</span></p></td><td id="-6uyfan_227"><p><code class="code" id="-6uyfan_230">static TaskPerformer inst()</code></p></td><td id="-6uyfan_228"><p>返回全局实例（单例）。</p></td></tr><tr id="-6uyfan_216"><td id="-6uyfan_231"><p><span class="control" id="-6uyfan_234">立即调度</span></p></td><td id="-6uyfan_232"><p><code class="code" id="-6uyfan_235">TaskHandle scheduleTask(ParamedAction action)</code></p></td><td id="-6uyfan_233"><p>将任务入队， <span class="control" id="-6uyfan_236">在随后帧</span>的 <code class="code" id="-6uyfan_237">Update()</code> 中取出并执行（每帧最多执行一个队列任务）。</p></td></tr><tr id="-6uyfan_217"><td id="-6uyfan_238"><p><span class="control" id="-6uyfan_241">条件一次</span></p></td><td id="-6uyfan_239"><p><code class="code" id="-6uyfan_242">TaskHandle scheduleTaskWhen(ParamedAction action, Func&lt;bool&gt; condition)</code></p></td><td id="-6uyfan_240"><p>条件首次为 <code class="code" id="-6uyfan_243">true</code> 时执行一次并移除。</p></td></tr><tr id="-6uyfan_218"><td id="-6uyfan_244"><p><span class="control" id="-6uyfan_247">条件重复</span></p></td><td id="-6uyfan_245"><p><code class="code" id="-6uyfan_248">TaskHandle scheduleRepeatingTaskWhen(ParamedAction action, Func&lt;bool&gt; condition, int executeTime = -1)</code></p></td><td id="-6uyfan_246"><p>每当条件为 <code class="code" id="-6uyfan_249">true</code> 即执行；通过 <code class="code" id="-6uyfan_250">executeTime</code> 限制总执行次数（<code class="code" id="-6uyfan_251">-1</code> 表示不限制）。</p></td></tr><tr id="-6uyfan_219"><td id="-6uyfan_252"><p><span class="control" id="-6uyfan_255">延迟一次</span></p></td><td id="-6uyfan_253"><p><code class="code" id="-6uyfan_256">TaskHandle scheduleTask(ParamedAction action, float delaySeconds)</code></p></td><td id="-6uyfan_254"><p>启动协程，延迟指定秒数后执行一次。</p></td></tr><tr id="-6uyfan_220"><td id="-6uyfan_257"><p><span class="control" id="-6uyfan_260">延迟重复</span></p></td><td id="-6uyfan_258"><p><code class="code" id="-6uyfan_261">TaskHandle scheduleRepeatingTask(ParamedAction action, float delaySeconds, int executeTime = -1)</code></p></td><td id="-6uyfan_259"><p>启动协程，按固定间隔循环执行； <code class="code" id="-6uyfan_262">executeTime</code> 限制总次数（<code class="code" id="-6uyfan_263">-1</code> 为无限）。</p></td></tr><tr id="-6uyfan_221"><td id="-6uyfan_264"><p><span class="control" id="-6uyfan_267">执行协程</span></p></td><td id="-6uyfan_265"><p><code class="code" id="-6uyfan_268">void executeIEnumerator(IEnumerator routine)</code></p></td><td id="-6uyfan_266"><p>便捷地启动一个协程。</p></td></tr><tr id="-6uyfan_222"><td id="-6uyfan_269"><p><span class="control" id="-6uyfan_272">外部进程</span></p></td><td id="-6uyfan_270"><p><code class="code" id="-6uyfan_273">static async void executeExe(string path, string[] args, bool useShell = false, bool createNoWindow = true, Action onComplete = null)</code></p></td><td id="-6uyfan_271"><p>以 <code class="code" id="-6uyfan_274">Process</code> 启动外部程序，异步等待退出并回调。</p></td></tr></tbody></table></div><aside class="prompt" data-type="tip" data-title="" id="-6uyfan_211"><p id="-6uyfan_275">构造/生命周期：单例在 <code class="code" id="-6uyfan_276">construct()</code> 中建立； <code class="code" id="-6uyfan_277">RuntimeInitializeOnLoadMethod</code> 负责在 <span class="control" id="-6uyfan_278">场景加载前</span>重置静态状态并收集 <code class="code" id="-6uyfan_279">onConstruct</code> 回调。你可以通过 <code class="code" id="-6uyfan_280">TaskPerformer.callOnConstruct(Action)</code> 在构造后立即执行一次初始化逻辑。</p></aside></section></section><section class="chapter"><h2 id="-6uyfan_8" data-toc="-6uyfan_8">线程安全</h2><ul class="list _bullet" id="-6uyfan_281"><li class="list__item" id="-6uyfan_283"><p id="-6uyfan_287">✅ <span class="control" id="-6uyfan_288">可在任意线程调用</span>： <code class="code" id="-6uyfan_289">scheduleTask*</code> 与 <code class="code" id="-6uyfan_290">schedule*When</code> 入队/登记使用 <code class="code" id="-6uyfan_291">Concurrent*</code> 容器。</p></li><li class="list__item" id="-6uyfan_284"><p id="-6uyfan_292">✅ <span class="control" id="-6uyfan_293">执行位置</span> ：所有任务最终<span class="control" id="-6uyfan_294">在主线程</span>运行（<code class="code" id="-6uyfan_295">Update()</code>/ 协程）。</p></li><li class="list__item" id="-6uyfan_285"><p id="-6uyfan_296">⚠️ <span class="control" id="-6uyfan_297">Unity API 限制</span> ：任务体如需访问 <code class="code" id="-6uyfan_298">GameObject</code>/<code class="code" id="-6uyfan_299">Transform</code> 等 Unity 对象，务必通过本执行器调度到主线程。</p></li><li class="list__item" id="-6uyfan_286"><p id="-6uyfan_300">⚠️ <span class="control" id="-6uyfan_301">吞吐特性</span> ：队列任务 <span class="control" id="-6uyfan_302">每帧最多执行一个</span> ；若短时入队过多，可能产生帧间排队延迟。</p></li></ul></section><section class="chapter"><h2 id="-6uyfan_9" data-toc="-6uyfan_9">故障排查</h2><ul class="list _bullet" id="-6uyfan_303"><li class="list__item" id="-6uyfan_305"><p id="-6uyfan_308"><span class="control" id="-6uyfan_310">症状</span> ：任务始终不执行</p><ul class="list _bullet" id="-6uyfan_309"><li class="list__item" id="-6uyfan_311"><p id="-6uyfan_314"><span class="control" id="-6uyfan_315">排查</span> ：场景中是否存在且 <span class="control" id="-6uyfan_316">启用</span> 的 <code class="code" id="-6uyfan_317">TaskPerformer</code> 组件；脚本是否在运行时被销毁或重复实例化（单例会销毁后来的副本）。</p></li><li class="list__item" id="-6uyfan_312"><p id="-6uyfan_318"><span class="control" id="-6uyfan_319">排查</span> ：是否在 <code class="code" id="-6uyfan_320">Awake/Start</code> 之前入队（仍然安全，但会在构造完成后才被执行）。</p></li><li class="list__item" id="-6uyfan_313"><p id="-6uyfan_321"><span class="control" id="-6uyfan_322">排查</span> ：是否误用了条件/次数限制（例如 <code class="code" id="-6uyfan_323">executeTime = 0</code> ，或条件从未为 <code class="code" id="-6uyfan_324">true</code>）。</p></li></ul></li><li class="list__item" id="-6uyfan_306"><p id="-6uyfan_325"><span class="control" id="-6uyfan_327">症状</span> ：通过标签执行时报 <span class="emphasis" id="-6uyfan_328">&ldquo;not found&rdquo;</span> 或签名异常</p><ul class="list _bullet" id="-6uyfan_326"><li class="list__item" id="-6uyfan_329"><p id="-6uyfan_331"><span class="control" id="-6uyfan_332">排查</span> ：是否调用过 <code class="code" id="-6uyfan_333">LabeledActionAttribute.load()</code> （在 Player 中不会自动执行）。</p></li><li class="list__item" id="-6uyfan_330"><p id="-6uyfan_334"><span class="control" id="-6uyfan_335">排查</span> ：被标注方法的签名是否为 <code class="code" id="-6uyfan_336">object Method(object[] args)</code> ；实例方法是否正确传入 <code class="code" id="-6uyfan_337">target</code>。</p></li></ul></li><li class="list__item" id="-6uyfan_307"><p id="-6uyfan_338"><span class="control" id="-6uyfan_340">症状</span> ：重复任务无法停止</p><ul class="list _bullet" id="-6uyfan_339"><li class="list__item" id="-6uyfan_341"><p id="-6uyfan_342"><span class="control" id="-6uyfan_343">排查</span> ：调用 <code class="code" id="-6uyfan_344">TaskHandle.cancel()</code> 仅对<span class="control" id="-6uyfan_345">未执行部分</span>生效；若使用 <code class="code" id="-6uyfan_346">scheduleRepeatingTaskWhen</code> ，也可通过设置 <code class="code" id="-6uyfan_347">executeTime</code> 有上限。</p></li></ul></li></ul></section><section class="chapter"><h2 id="taskperformer" data-toc="taskperformer">性能说明（仅 <code class="code" id="-6uyfan_353">TaskPerformer</code> 方法）</h2><aside class="prompt" data-type="tip" data-title="" id="-6uyfan_349"><p id="-6uyfan_354">数值为相对能耗，基于经验量级， <span class="control" id="-6uyfan_355">仅用于横向对比</span> ；实际表现与平台、编译设置、任务内容有关。</p></aside><div class="table-wrapper"><table class="wide" id="-6uyfan_350"><thead><tr class="ijRowHead" id="-6uyfan_356"><th id="-6uyfan_366"><p>操作</p></th><th id="-6uyfan_367"><p>能耗（相对）</p></th><th id="-6uyfan_368"><p>备注</p></th></tr></thead><tbody><tr id="-6uyfan_357"><td id="-6uyfan_369"><p><code class="code" id="-6uyfan_372">var value = 1f</code></p></td><td id="-6uyfan_370"><p><code class="code" id="-6uyfan_373">1</code></p></td><td id="-6uyfan_371"><p>基线</p></td></tr><tr id="-6uyfan_358"><td id="-6uyfan_374"><p><span class="control" id="-6uyfan_377">立即调度入队</span> <code class="code" id="-6uyfan_378">scheduleTask(...)</code></p></td><td id="-6uyfan_375"><p><code class="code" id="-6uyfan_379">8-20</code></p></td><td id="-6uyfan_376"><p><code class="code" id="-6uyfan_380">ConcurrentQueue</code> 入队 + 包装句柄分配</p></td></tr><tr id="-6uyfan_359"><td id="-6uyfan_381"><p><span class="control" id="-6uyfan_384">Update 取出并执行一次</span></p></td><td id="-6uyfan_382"><p><code class="code" id="-6uyfan_385">10-30</code></p></td><td id="-6uyfan_383"><p>出队 + 委托调用 + 状态更新； <span class="control" id="-6uyfan_386">每帧最多 1 次</span></p></td></tr><tr id="-6uyfan_360"><td id="-6uyfan_387"><p><span class="control" id="-6uyfan_390">条件登记</span> <code class="code" id="-6uyfan_391">scheduleTaskWhen</code></p></td><td id="-6uyfan_388"><p><code class="code" id="-6uyfan_392">15-35</code></p></td><td id="-6uyfan_389"><p>建立 <code class="code" id="-6uyfan_393">Func&lt;bool&gt;</code>-&gt; 列表映射</p></td></tr><tr id="-6uyfan_361"><td id="-6uyfan_394"><p><span class="control" id="-6uyfan_397">条件评估（每条件/每帧）</span></p></td><td id="-6uyfan_395"><p><code class="code" id="-6uyfan_398">3-8</code></p></td><td id="-6uyfan_396"><p><code class="code" id="-6uyfan_399">whenTasks</code>/<code class="code" id="-6uyfan_400">repeatingWhenTasks</code> 扫描与判断</p></td></tr><tr id="-6uyfan_362"><td id="-6uyfan_401"><p><span class="control" id="-6uyfan_404">条件触发执行</span></p></td><td id="-6uyfan_402"><p><code class="code" id="-6uyfan_405">10-30</code></p></td><td id="-6uyfan_403"><p>同&ldquo;Update 执行一次&rdquo;</p></td></tr><tr id="-6uyfan_363"><td id="-6uyfan_406"><p><span class="control" id="-6uyfan_409">延迟一次</span> <code class="code" id="-6uyfan_410">scheduleTask(..., d)</code></p></td><td id="-6uyfan_407"><p><code class="code" id="-6uyfan_411">25-60</code></p></td><td id="-6uyfan_408"><p>启动协程 + <code class="code" id="-6uyfan_412">WaitForSeconds</code> ；实际执行成本同上</p></td></tr><tr id="-6uyfan_364"><td id="-6uyfan_413"><p><span class="control" id="-6uyfan_416">延迟重复</span> <code class="code" id="-6uyfan_417">scheduleRepeatingTask</code></p></td><td id="-6uyfan_414"><p><code class="code" id="-6uyfan_418">25-60</code> /tick</p></td><td id="-6uyfan_415"><p>每次触发均需协程 Tick 与委托调用</p></td></tr><tr id="-6uyfan_365"><td id="-6uyfan_419"><p><span class="control" id="-6uyfan_422">外部进程</span> <code class="code" id="-6uyfan_423">executeExe(...)</code></p></td><td id="-6uyfan_420"><p><code class="code" id="-6uyfan_424">100-3000+</code></p></td><td id="-6uyfan_421"><p>受系统/程序复杂度影响极大；不在主线程执行，但完成回调在主线程</p></td></tr></tbody></table></div><aside class="prompt" data-type="tip" data-title="" id="-6uyfan_351"><p id="-6uyfan_425">调优建议：若短时间需要执行大量任务，可在单个任务中批处理，或在 <code class="code" id="-6uyfan_426">Update()</code> 中增加出队数量（需要修改源码：当前实现每帧仅 <code class="code" id="-6uyfan_427">TryDequeue</code> 一次）。</p></aside></section><section class="chapter"><h2 id="-6uyfan_11" data-toc="-6uyfan_11">使用建议</h2><ul class="list _bullet" id="-6uyfan_428"><li class="list__item" id="-6uyfan_429"><p id="-6uyfan_432">对 <span class="control" id="-6uyfan_433">高频重复逻辑</span> ，优先使用 <code class="code" id="-6uyfan_434">scheduleRepeatingTask</code> （固定间隔）或 <code class="code" id="-6uyfan_435">scheduleRepeatingTaskWhen</code> （条件触发），并合理设置 <code class="code" id="-6uyfan_436">executeTime</code> 上限与 <code class="code" id="-6uyfan_437">cancel()</code> 时机。</p></li><li class="list__item" id="-6uyfan_430"><p id="-6uyfan_438">通过 <code class="code" id="-6uyfan_439">TaskHandle.onComplete</code> 做收尾/续作；对于串行依赖，可在回调内继续调度下一步。</p></li><li class="list__item" id="-6uyfan_431"><p id="-6uyfan_440">使用标记动作时，务必保证 <span class="control" id="-6uyfan_441">唯一标签</span> 与 <span class="control" id="-6uyfan_442">正确签名</span> （<code class="code" id="-6uyfan_443">object(object[])</code> ），避免运行期异常。</p></li></ul></section><div class="last-modified">17 八月 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="hierarchy-button.html" class="navigation-links__prev">Hierarchy Button</a><a href="prefab-parameter.html" class="navigation-links__next">Prefab Parameter</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>