<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-08-17T17:42:39.0708858"><title>Insertion Event System | Fries</title><script type="application/json" id="virtual-toc-data">[{"id":"-v69c5b_6","level":0,"title":"快速开始","anchor":"#-v69c5b_6"},{"id":"api","level":0,"title":"API 参考","anchor":"#api"},{"id":"inspector","level":0,"title":"Inspector 支持","anchor":"#inspector"},{"id":"-v69c5b_9","level":0,"title":"线程安全","anchor":"#-v69c5b_9"},{"id":"-v69c5b_10","level":0,"title":"故障排查","anchor":"#-v69c5b_10"},{"id":"-v69c5b_11","level":0,"title":"性能说明（相对量级）","anchor":"#-v69c5b_11"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Insertion Event System | Fries"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Fries Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/insertion-event-system.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Insertion Event System | Fries"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/insertion-event-system.html#webpage",
    "url": "writerside-documentation/insertion-event-system.html",
    "name": "Insertion Event System | Fries",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Fries Help"
}</script><!-- End Schema.org --></head><body data-id="Insertion_Event_System" data-main-title="Insertion Event System" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Overview.md|Fries Utils Pack 总览"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Fries  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Insertion_Event_System" id="Insertion_Event_System.md">Insertion Event System</h1><p id="-v69c5b_3"><code class="code" id="-v69c5b_12">InsertionEventSystem</code> 是一个用于 <span class="control" id="-v69c5b_13">声明（declare）</span>、 <span class="control" id="-v69c5b_14">注册（register）</span> 与 <span class="control" id="-v69c5b_15">触发（trigger）</span> &ldquo;插入式事件（Insertion Events）&rdquo;的 <code class="code" id="-v69c5b_16">MonoBehaviour</code>。 <br> 它通过一对 Attribute（<code class="code" id="-v69c5b_18">InsertionEventDeclarer</code>/<code class="code" id="-v69c5b_19">InsertionEventListener</code> ）进行 <span class="control" id="-v69c5b_20">反射式自动发现</span> ，并集中管理在一个全局实例中（<code class="code" id="-v69c5b_21">InsertionEventSystem.inst</code>）。</p><aside class="prompt" data-type="tip" data-title="" id="-v69c5b_4"><p id="-v69c5b_22">设计要点：</p><ul class="list _bullet" id="-v69c5b_23"><li class="list__item" id="-v69c5b_24"><p id="-v69c5b_28">事件由 <span class="control" id="-v69c5b_29">事件所属类型（Type） + 事件名（string）</span> 唯一定义。</p></li><li class="list__item" id="-v69c5b_25"><p id="-v69c5b_30">监听器以 <span class="control" id="-v69c5b_31">唯一名称</span> 注册到某个事件，重复名称将被拒绝。唯一名称通常由 <span class="control" id="-v69c5b_32">监听器所在类完整路径名</span> 加 <span class="control" id="-v69c5b_33">监听器方法名</span> 组成</p></li><li class="list__item" id="-v69c5b_26"><p id="-v69c5b_34">参数匹配采用&ldquo; <span class="control" id="-v69c5b_35">监听器参数类型必须是事件参数类型的同型或基类</span> &rdquo;的兼容规则。</p></li><li class="list__item" id="-v69c5b_27"><p id="-v69c5b_36">Inspector 提供了 <code class="code" id="-v69c5b_37">InsertionEventInformation</code> 的自定义 Drawer，方便查看声明结果与监听器列表（只读）。</p></li></ul></aside><section class="chapter"><h2 id="-v69c5b_6" data-toc="-v69c5b_6">快速开始</h2><ol class="list _decimal" id="-v69c5b_38" type="1"><li class="list__item" id="-v69c5b_45"><p id="-v69c5b_48">在首个加载场景的某个空物体（或启动器）上 <span class="control" id="-v69c5b_49">添加组件</span>： <code class="code" id="-v69c5b_50">InsertionEventSystem</code>。 <br> 该组件带有 <code class="code" id="-v69c5b_52">DefaultExecutionOrder(-10000)</code> ，可尽早初始化。</p></li><li class="list__item" id="-v69c5b_46"><p id="-v69c5b_53">（可选）在 <span class="control" id="-v69c5b_54">Inspector</span> 的 <code class="code" id="-v69c5b_55">loadAssemblies</code> 中填入要扫描的程序集名称（字符串），用于限定 <span class="control" id="-v69c5b_56">事件声明/监听器</span> 的反射来源。留空则使用默认策略（即 Fries包 + Assembly.Player包）。</p></li><li class="list__item" id="-v69c5b_47"><p id="-v69c5b_57">使用 <span class="control" id="-v69c5b_58">Attribute</span> 在任意类型上声明事件</p></li></ol><div class="code-block" data-lang="none">
using System;
using UnityEngine;
using Fries.InsertionEventSys;

// 1) 声明：填入 事件名 和 所有参数类型
[InsertionEventDeclarer(&quot;OnKilled&quot;, typeof(GameObject), typeof(int))]
public class Enemy { /* ... */ }
</div><ol class="list _decimal" id="-v69c5b_40" type="1" start="4"><li class="list__item" id="-v69c5b_59"><p id="-v69c5b_60">在任意时机 <span class="control" id="-v69c5b_61">触发事件</span>：</p></li></ol><div class="code-block" data-lang="none">
// 触发时需提供“事件归属类型”“事件名”与实参：
InsertionEventSystem.inst.triggerListener(typeof(Enemy), &quot;OnKilled&quot;, enemyGO, 100);
</div><aside class="prompt" data-type="tip" data-title="" id="-v69c5b_42"><p id="-v69c5b_62">生命周期说明： <span class="control" id="-v69c5b_63">自动发现/注册</span> 会在 <code class="code" id="-v69c5b_64">InsertionEventSystem.Start()</code> 中触发。 <br> 为确保工程启动阶段稳定，实际的事件触发请在这之后进行</p></aside><ol class="list _decimal" id="-v69c5b_43" type="1" start="5"><li class="list__item" id="-v69c5b_66"><p id="-v69c5b_67">并在<span class="control" id="-v69c5b_68">静态方法</span>上声明监听器：</p></li></ol><div class="code-block" data-lang="none">
// 2) 监听：在“静态方法”上标注；返回 void；形参类型需与事件形参兼容
[InsertionEventListener(typeof(Enemy), &quot;OnKilled&quot;)]
static void LogKill(GameObject who, int score)
{
    Debug.Log($&quot;Killed: {who?.name}, +{score}&quot;);
}
</div></section><section class="chapter"><h2 id="api" data-toc="api">API 参考</h2><section class="chapter"><h3 id="attributes" data-toc="attributes">Attributes</h3><div class="table-wrapper"><table class="wide" id="-v69c5b_71"><thead><tr class="ijRowHead" id="-v69c5b_73"><th id="-v69c5b_76"><p>名称</p></th><th id="-v69c5b_77"><p>目标</p></th><th id="-v69c5b_78"><p>构造签名</p></th><th id="-v69c5b_79"><p>行为</p></th></tr></thead><tbody><tr id="-v69c5b_74"><td id="-v69c5b_80"><p><code class="code" id="-v69c5b_84">InsertionEventDeclarer</code></p></td><td id="-v69c5b_81"><p><code class="code" id="-v69c5b_85">Class</code> （允许多次）</p></td><td id="-v69c5b_82"><p><code class="code" id="-v69c5b_86">InsertionEventDeclarer(string eventName, params Type[] argsTypes)</code></p></td><td id="-v69c5b_83"><p>声明&ldquo;由当前类型发布&rdquo;的事件，记录事件名与形参类型。启动后通过反射自动调用 <code class="code" id="-v69c5b_87">declareEvent</code>。</p></td></tr><tr id="-v69c5b_75"><td id="-v69c5b_88"><p><code class="code" id="-v69c5b_92">InsertionEventListener</code></p></td><td id="-v69c5b_89"><p><code class="code" id="-v69c5b_93">Method</code></p></td><td id="-v69c5b_90"><p><code class="code" id="-v69c5b_94">InsertionEventListener(Type type, string eventName)</code></p></td><td id="-v69c5b_91"><p>将<span class="control" id="-v69c5b_95">静态</span> <code class="code" id="-v69c5b_96">void</code> 方法作为对应事件的监听器自动注册。方法形参需与事件形参<span class="control" id="-v69c5b_97">等长</span> ，且每个形参为事件形参类型的<span class="control" id="-v69c5b_98">同型或基类</span>。</p></td></tr></tbody></table></div><aside class="prompt" data-type="tip" data-title="" id="-v69c5b_72"><p id="-v69c5b_99">监听器唯一名：自动发现时使用 <code class="code" id="-v69c5b_100">Assembly.FullName + &quot;::&quot; + DeclaringType.Name + &quot;::&quot; + Method.Name</code> ，避免冲突。手动注册时请自行保证唯一。</p></aside></section><section class="chapter"><h3 id="fries-insertioneventsys-insertioneventsystem" data-toc="fries-insertioneventsys-insertioneventsystem">运行时系统： <code class="code" id="-v69c5b_104">Fries.InsertionEventSys.InsertionEventSystem</code></h3><div class="table-wrapper"><table class="wide" id="-v69c5b_102"><thead><tr class="ijRowHead" id="-v69c5b_105"><th id="-v69c5b_110"><p>方法</p></th><th id="-v69c5b_111"><p>签名</p></th><th id="-v69c5b_112"><p>行为</p></th></tr></thead><tbody><tr id="-v69c5b_106"><td id="-v69c5b_113"><p><code class="code" id="-v69c5b_116">declareEvent</code></p></td><td id="-v69c5b_114"><p><code class="code" id="-v69c5b_117">void declareEvent(Type type, string eventName, Type[] parameters = null)</code></p></td><td id="-v69c5b_115"><p>为给定类型注册一个事件定义（参数类型可空表示无参），并更新 Inspector 中可视的 <code class="code" id="-v69c5b_118">events</code> 列表。</p></td></tr><tr id="-v69c5b_107"><td id="-v69c5b_119"><p><code class="code" id="-v69c5b_122">registerListener</code></p></td><td id="-v69c5b_120"><p><code class="code" id="-v69c5b_123">void registerListener(Type type, string eventName, string listenerName, MulticastDelegate listener)</code></p></td><td id="-v69c5b_121"><p>注册监听器。重复名称会抛出异常；参数个数与兼容性不满足会报错并拒绝注册。</p></td></tr><tr id="-v69c5b_108"><td id="-v69c5b_124"><p><code class="code" id="-v69c5b_127">unregisterListener</code></p></td><td id="-v69c5b_125"><p><code class="code" id="-v69c5b_128">void unregisterListener(Type type, string eventName, string listenerName)</code></p></td><td id="-v69c5b_126"><p>解除注册（若不存在则静默无事发生，但会校验类型与事件是否存在）。</p></td></tr><tr id="-v69c5b_109"><td id="-v69c5b_129"><p><code class="code" id="-v69c5b_132">triggerListener</code></p></td><td id="-v69c5b_130"><p><code class="code" id="-v69c5b_133">void triggerListener(Type type, string eventName, params object[] objects)</code></p></td><td id="-v69c5b_131"><p>触发事件。会校验参数个数与运行时类型： <code class="code" id="-v69c5b_134">expected.IsInstanceOfType(arg)</code> ；按注册顺序逐一 <code class="code" id="-v69c5b_135">DynamicInvoke</code> ，单个监听器异常会被捕获并记录，不影响后续监听器。</p></td></tr></tbody></table></div></section></section><section class="chapter"><h2 id="inspector" data-toc="inspector">Inspector 支持</h2><ul class="list _bullet" id="-v69c5b_136"><li class="list__item" id="-v69c5b_139"><p id="-v69c5b_140"><code class="code" id="-v69c5b_142">InsertionEventInformationDrawer</code> （Editor-only）将 <code class="code" id="-v69c5b_143">events</code> 绘制为：</p><ul class="list _bullet" id="-v69c5b_141"><li class="list__item" id="-v69c5b_144"><p id="-v69c5b_147"><span class="control" id="-v69c5b_148">头行</span> ：折叠开关 + <code class="code" id="-v69c5b_149">insertedClass</code>/<code class="code" id="-v69c5b_150">eventName</code>/<code class="code" id="-v69c5b_151">Listeners: N</code> 三列只读框；</p></li><li class="list__item" id="-v69c5b_145"><p id="-v69c5b_152"><span class="control" id="-v69c5b_153">参数行</span> ：按 token 自动换行显示 <code class="code" id="-v69c5b_154">argsTypes</code>；</p></li><li class="list__item" id="-v69c5b_146"><p id="-v69c5b_155"><span class="control" id="-v69c5b_156">展开区</span> ：每个监听器名称按行只读展示；</p></li></ul></li></ul><aside class="prompt" data-type="tip" data-title="" id="-v69c5b_137"><p id="-v69c5b_157">该区域仅用于<span class="control" id="-v69c5b_158">查看</span> 。如需增删/修改，请通过代码或 Attribute 进行。</p></aside></section><section class="chapter"><h2 id="-v69c5b_9" data-toc="-v69c5b_9">线程安全</h2><ul class="list _bullet" id="-v69c5b_159"><li class="list__item" id="-v69c5b_161"><p id="-v69c5b_163">Unity 的 <code class="code" id="-v69c5b_164">GameObject</code> /反射/字典修改 <span class="control" id="-v69c5b_165">仅在主线程安全</span>。</p></li><li class="list__item" id="-v69c5b_162"><p id="-v69c5b_166">当前实现未做并发保护； <span class="control" id="-v69c5b_167">请在主线程声明、注册与触发事件</span>。</p></li></ul></section><section class="chapter"><h2 id="-v69c5b_10" data-toc="-v69c5b_10">故障排查</h2><ul class="list _bullet" id="-v69c5b_168"><li class="list__item" id="-v69c5b_170"><p id="-v69c5b_176"><span class="control" id="-v69c5b_178">症状</span> ：触发时报&ldquo;Given Type XXX has no available events!&rdquo;</p><ul class="list _bullet" id="-v69c5b_177"><li class="list__item" id="-v69c5b_179"><p id="-v69c5b_180"><span class="control" id="-v69c5b_181">排查</span> ：确认已挂载并激活 <code class="code" id="-v69c5b_182">InsertionEventSystem</code> ；是否在 <code class="code" id="-v69c5b_183">Start()</code> 之前触发了还未声明的事件；是否限制了 <code class="code" id="-v69c5b_184">loadAssemblies</code> 导致未扫描到声明。</p></li></ul></li><li class="list__item" id="-v69c5b_171"><p id="-v69c5b_185"><span class="control" id="-v69c5b_187">症状</span> ：注册时报&ldquo;has no event called YYY!&rdquo;</p><ul class="list _bullet" id="-v69c5b_186"><li class="list__item" id="-v69c5b_188"><p id="-v69c5b_189"><span class="control" id="-v69c5b_190">排查</span> ：事件是否已通过 Attribute 或 <code class="code" id="-v69c5b_191">declareEvent</code> 成功声明； <code class="code" id="-v69c5b_192">type + eventName</code> 是否拼写一致。</p></li></ul></li><li class="list__item" id="-v69c5b_172"><p id="-v69c5b_193"><span class="control" id="-v69c5b_195">症状</span> ：参数不匹配（个数/类型）</p><ul class="list _bullet" id="-v69c5b_194"><li class="list__item" id="-v69c5b_196"><p id="-v69c5b_197"><span class="control" id="-v69c5b_198">排查</span> ：监听器方法参数个数必须<span class="control" id="-v69c5b_199">等于</span>事件形参个数；每个参数类型需为事件对应参数类型的<span class="control" id="-v69c5b_200">同型或基类</span> ；触发时实参需满足 <code class="code" id="-v69c5b_201">expected.IsInstanceOfType(arg)</code>。</p></li></ul></li><li class="list__item" id="-v69c5b_173"><p id="-v69c5b_202"><span class="control" id="-v69c5b_204">症状</span> ：监听器重复（抛异常）</p><ul class="list _bullet" id="-v69c5b_203"><li class="list__item" id="-v69c5b_205"><p id="-v69c5b_206"><span class="control" id="-v69c5b_207">排查</span> ：每个 <code class="code" id="-v69c5b_208">listenerName</code> 必须在该 <code class="code" id="-v69c5b_209">type + eventName</code> 下唯一；自动发现已使用&ldquo;程序集+类型+方法&rdquo;避免冲突，手动注册时请自保唯一。</p></li></ul></li><li class="list__item" id="-v69c5b_174"><p id="-v69c5b_210"><span class="control" id="-v69c5b_212">症状</span> ：监听器不执行/只执行部分</p><ul class="list _bullet" id="-v69c5b_211"><li class="list__item" id="-v69c5b_213"><p id="-v69c5b_214"><span class="control" id="-v69c5b_215">排查</span> ：单个监听器中的异常会被捕获并记录，但不影响后续监听器执行；请查看日志。</p></li></ul></li><li class="list__item" id="-v69c5b_175"><p id="-v69c5b_216"><span class="control" id="-v69c5b_218">症状</span> ：自动发现未生效</p><ul class="list _bullet" id="-v69c5b_217"><li class="list__item" id="-v69c5b_219"><p id="-v69c5b_220"><span class="control" id="-v69c5b_221">排查</span> ：监听器方法必须是 <span class="control" id="-v69c5b_222">静态</span> 且返回 <code class="code" id="-v69c5b_223">void</code> ；特性参数是否填写正确； <code class="code" id="-v69c5b_224">loadAssemblies</code> 是否覆盖到目标程序集。</p></li></ul></li></ul></section><section class="chapter"><h2 id="-v69c5b_11" data-toc="-v69c5b_11">性能说明（相对量级）</h2><div class="table-wrapper"><table class="wide" id="-v69c5b_225"><thead><tr class="ijRowHead" id="-v69c5b_227"><th id="-v69c5b_234"><p>方法</p></th><th id="-v69c5b_235"><p>能耗（相对）</p></th></tr></thead><tbody><tr id="-v69c5b_228"><td id="-v69c5b_236"><p><code class="code" id="-v69c5b_238">var value = 1f</code></p></td><td id="-v69c5b_237"><p><code class="code" id="-v69c5b_239">1</code></p></td></tr><tr id="-v69c5b_229"><td id="-v69c5b_240"><p><code class="code" id="-v69c5b_242">GetComponent&lt;T&gt;()</code></p></td><td id="-v69c5b_241"><p><code class="code" id="-v69c5b_243">50 - 200</code></p></td></tr><tr id="-v69c5b_230"><td id="-v69c5b_244"><p><code class="code" id="-v69c5b_246">declareEvent</code></p></td><td id="-v69c5b_245"><p><code class="code" id="-v69c5b_247">25 - 120</code> （首次），随后 <code class="code" id="-v69c5b_248">15 - 80</code></p></td></tr><tr id="-v69c5b_231"><td id="-v69c5b_249"><p><code class="code" id="-v69c5b_251">registerListener</code></p></td><td id="-v69c5b_250"><p><code class="code" id="-v69c5b_252">120 - 400</code> （首次），随后 <code class="code" id="-v69c5b_253">60 - 220</code></p></td></tr><tr id="-v69c5b_232"><td id="-v69c5b_254"><p><code class="code" id="-v69c5b_256">unregisterListener</code></p></td><td id="-v69c5b_255"><p><code class="code" id="-v69c5b_257">20 - 90</code></p></td></tr><tr id="-v69c5b_233"><td id="-v69c5b_258"><p><code class="code" id="-v69c5b_260">triggerListener</code></p></td><td id="-v69c5b_259"><p>每监听器调用 <code class="code" id="-v69c5b_261">3000 - 20000</code></p></td></tr></tbody></table></div><aside class="prompt" data-type="tip" data-title="" id="-v69c5b_226"><p id="-v69c5b_262">为了减轻负担，监听器不应该每帧都调用。在未来可能会修复这个潜在的性能问题</p></aside></section><div class="last-modified">17 八月 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="event-functions.html" class="navigation-links__prev">Event Functions</a><a href="static-method1.html" class="navigation-links__next">Static Method Field</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>